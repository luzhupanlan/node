<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>笔记</title>
  <!-- <link rel="stylesheet" href="lib/css/monokai-sublime.css"> -->
  <link rel="stylesheet" href="lib/css/default.min.css">
  <link rel="stylesheet" href="lib/css/vs2015.css">
  <link rel="stylesheet" href="lib/css/zTreeStyle/zTreeStyle.css">
  <link rel="stylesheet" href="lib/css/base.css">
  <link rel="stylesheet" href="lib/css/index.css">
</head>

<body>
  <div style='width:25%;'>
    <ul id="tree" class="ztree" style='width:100%'>

    </ul>
  </div>
  <div id='readme' style='width:70%;margin-left:20%;'>
    <article class='markdown-body'><h1 id="-">基本概念</h1>
<h2 id="-">浏览器与服务器的交互流程</h2>
<ol>
<li>浏览器通过地址栏发出<strong>请求</strong></li>
<li>通过DNS服务器解析，得到域名对应的ip地址</li>
<li>根据ip地址，访问服务器具体的某个文件</li>
<li>服务器响应这个具体的文件</li>
<li>浏览器获取响应，进行显示</li>
</ol>
<p><img src="imgs/浏览器与服务器交互.png" alt=""></p>
<p>问题1：我们写的html页面，存放在哪儿？</p>
<p>问题2：我们写的html页面，在哪里执行（显示）？</p>
<p>前端开发：以浏览器为宿主环境，结合 HTML、CSS、Javascript等技术，而进行的一系列开发，通常称之为<strong>前端开发</strong>。</p>
<p>服务器端开发：HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为<strong>服务端开发</strong>。 </p>
<p><strong>nodejs：服务端的javascript开发，用于开发服务端程序的</strong></p>
<h2 id="-nodejs">为什么要学习nodejs</h2>
<p>为什么要学习服务端的开发？</p>
<ol>
<li>通过学习Node.js开发理解<strong>服务器开发</strong>、<strong>Web请求和响应过程</strong>、 <strong>了解服务器端如何与客户端配合</strong></li>
<li>作为前端开发工程师（FE）需要具备一定的服务端开发能力<ul>
<li>了解什么是服务端渲染？</li>
<li>了解服务端如何编写接口？</li>
</ul>
</li>
<li>全栈工程师的必经之路</li>
</ol>
<p>服务器端开发语言有很多，为什么要选择nodejs</p>
<ol>
<li>降低编程语言切换的成本(nodejs实质上用的还是javascript)</li>
<li>NodeJS是前端项目的基础设施，前端项目中用到的大量工具，都是基于nodejs实现的</li>
<li>nodejs在处理高并发上有得天独厚的优势</li>
<li><strong>对于前端工程师，面试时对于nodejs有一定的要求</strong></li>
</ol>
<p>参考资料：</p>
<p><a href="https://www.ibm.com/developerworks/cn/opensource/os-nodejs/">Node.js 究竟是什么？</a></p>
<p><a href="http://blog.jobbole.com/100058/">为什么要用 Node.js</a></p>
<h2 id="node-js-">node.js 是什么？</h2>
<p>node.js，也叫作node，或者nodejs，指的都是一个东西。</p>
<ol>
<li><a href="https://nodejs.org/">node.js官方网站</a></li>
<li><a href="http://nodejs.cn/">node.js中文网</a></li>
<li><a href="https://cnodejs.org/">node.js 中文社区</a></li>
</ol>
<p>Node.js是一个Javascript运行环境(runtime environment)，发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。Node.js对一些特殊用例进行优化，提供替代的API，使得V8在非浏览器环境下运行得更好。 </p>
<ul>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 </li>
</ul>
<pre><code>1. nodejs不是一门新的编程语言，nodejs是在服务端运行javascript的运行环境
2. 运行环境：写得程序想要运行必须要有对应的运行环境
    php代码必须要有apache服务器
    在web端，浏览器就是javascript的运行环境
    在node端，nodejs就是javascript的运行环境
2. javascript并不只是能运行在浏览器端，浏览器端能够运行js是因为浏览器有js解析器，因此只需要有js解析器，任何软件都可以运行js。
3. nodejs可以在服务端运行js，因为nodejs是基于chrome v8的js引擎。
</code></pre><ul>
<li>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。  </li>
<li>Node.js 的包管理器 npm，是全球最大的开源库生态系统。 </li>
</ul>
<p><strong>nodejs的本质：不是一门新的编程语言，nodejs是javascript运行在服务端的运行环境，编程语言还是javascript</strong></p>
<h2 id="nodejs-js-">nodejs与浏览器端js的区别</h2>
<p>nodejs是基于chrome v8引擎的，因此nodejs可以和浏览器一样执行js代码，但是二者执行的js还是有一定区别的。</p>
<p><img src="./imgs/nodejs.png" alt=""></p>
<p>思考：</p>
<ol>
<li>在浏览器端，可以使用javascript操作文件么？</li>
<li>在nodejs端，可以使用BOM和DOM的方法么？</li>
<li>我们学习nodejs，学习什么内容？ </li>
</ol>
<h2 id="nodejs-">nodejs可以干什么？</h2>
<ol>
<li>开发服务端程</li>
<li>开发命令行工具（CLI），比如npm,webpack,gulp等</li>
<li>开发桌面应用程序（借助 node-webkit、electron 等框架实现）</li>
</ol>
<h1 id="-nodejs">安装nodejs</h1>
<h2 id="nodejs-">nodejs版本</h2>
<p>下载地址</p>
<ul>
<li><a href="https://nodejs.org/en/download/">当前版本</a></li>
<li><a href="https://nodejs.org/en/download/releases/">历史版本</a></li>
</ul>
<p>官网术语解释</p>
<ul>
<li>LTS 版本：Long-term Support 版本，长期支持版，即稳定版。</li>
<li>Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。</li>
</ul>
<p>查看node版本</p>
<pre><code class="lang-bash">node -v
</code></pre>
<h2 id="-">环境变量</h2>
<p>当要求系统运行一个<strong>程序</strong> 而没有告诉它程序所在的完整路径时，</p>
<ol>
<li>首先在<strong>当前目录</strong>中查找和该字符串匹配的可执行文件</li>
<li>进入用户 path 环境变量查找</li>
<li>进入系统 path 环境变量查找</li>
</ol>
<p>配置环境变量：</p>
<pre><code class="lang-javas">找到环境变量：计算机 --右键--&gt; 属性 --&gt; 高级系统设置 --&gt; 高级 --&gt; 环境变量
</code></pre>
<p>直接将可执行程序所在目录配置到PATH中</p>
<pre><code class="lang-javascript">//如果是window7操作系统，注意要用分号;隔开，不要覆盖原来的内容
D:\Program Files\feiq
</code></pre>
<h1 id="-nodejs-">运行nodejs程序</h1>
<h2 id="-repl-">方式一：REPL介绍</h2>
<ol>
<li>REPL 全称: Read-Eval-Print-Loop（交互式解释器）<ul>
<li>R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li>
<li>E 执行 - 执行输入的数据结构</li>
<li>P 打印 - 输出结果</li>
<li>L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。</li>
</ul>
</li>
<li>在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能）<ul>
<li>直接在控制台输入 <code>node</code> 命令进入 REPL 环境</li>
</ul>
</li>
<li>按两次 Control + C 退出REPL界面 或者 输入 <code>.exit</code> 退出 REPL 界面<ul>
<li>按住 control 键不要放开, 然后按两下 c 键</li>
</ul>
</li>
</ol>
<h2 id="-node-js-">方式二：使用node执行js文件</h2>
<ul>
<li><p>创建js文件 <code>helloworld.js</code></p>
</li>
<li><p>写nodejs的内容：<code>console.log(&#39;hello nodejs&#39;)</code></p>
</li>
<li>打开命令窗口 <code>cmd</code><ul>
<li>shift加右键打开命令窗口，执行 <code>node 文件名.js</code>即可</li>
<li>给vscode安装<code>terminal</code>插件，直接在vscode中执行</li>
</ul>
</li>
<li>执行命令：<code>node helloworld.js</code></li>
</ul>
<p>注意：在nodejs中是无法使用DOM和BOM的内容的，因此<code>document, window</code>等内容是无法使用的。</p>
<h1 id="global-">global模块-全局变量</h1>
<p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。</p>
<p>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 <code>global</code>，所有全局变量（除了 global 本身以外）都是 global 对象的属性。</p>
<p>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<p>常用的global属性</p>
<pre><code class="lang-javascript">console: 用于打印日志
setTimeout/clearTimeout: 设置清除延时器
setInterval/clearInterval: 设置清除定时器

__dirname: 当前文件的路径，不包括文件名
__filename： 获取当前文件的路径，包括文件名

//与模块化相关的，模块化的时候会用到
require
exports
module
</code></pre>
<h1 id="fs-">fs模块</h1>
<blockquote>
<p>fs模块是nodejs中最常用的一个模块，因此掌握fs模块非常的有必要，fs模块的方法非常多,用到了哪个查哪个即可。</p>
<p>文档地址：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
</blockquote>
<p>  在nodejs中，提供了fs模块，这是node的核心模块</p>
<p>  注意：</p>
<ol>
<li>除了global模块中的内容可以直接使用，其他模块都是需要加载的。</li>
<li>fs模块不是全局的，不能直接使用。因此需要导入才能使用。</li>
</ol>
<pre><code class="lang-javascript">var fs = require(&quot;fs&quot;);
</code></pre>
<h2 id="-">读取文件</h2>
<blockquote>
<p>语法：fs.readFile(path[, options], callback)</p>
</blockquote>
<p>方式一：不传编码参数</p>
<pre><code class="lang-javascript">//参数1： 文件的名字
//参数2： 读取文件的回调函数
  //参数1：错误对象，如果读取失败，err会包含错误信息，如果读取成功，err是null
  //参数2：读取成功后的数据（是一个Buffer对象）
fs.readFile(&quot;data.txt&quot;, function(err, data){
  console.log(err);
  console.log(data);
});
</code></pre>
<p>方式二：传编码参数</p>
<pre><code class="lang-javascript">//参数1： 文件的路径
//参数2： 编码，如果设置了，返回一个字符串，如果没有设置，会返回一个buffer对象
//参数3： 回调函数
fs.readFile(&quot;data.txt&quot;, &quot;utf8&quot;,function(err, data){
  console.log(err);
  console.log(data);
});
</code></pre>
<p>关于Buffer对象</p>
<pre><code class="lang-javascript">1. Buffer对象是Nodejs用于处理二进制数据的。
2. 其实任意的数据在计算机底层都是二进制数据，因为计算机只认识二进制。
3. 所以读取任意的文件，返回的结果都是二进制数据，即Buffer对象
4. Buffer对象可以调用toString()方法转换成字符串。
</code></pre>
<h2 id="-">写文件</h2>
<blockquote>
<p>语法：fs.writeFile(file, data[, options], callback)</p>
</blockquote>
<pre><code class="lang-javascript">//参数1：写入的文件名(如果文件不存在，会自动创建)
//参数2：写入的文件内容（注意：写入的内容会覆盖以前的内容）
//参数3：写文件后的回调函数
fs.writeFile(&quot;2.txt&quot;, &quot;hello world, 我是一个中国人&quot;, function(err){
  if(err) {
    return console.log(&quot;写入文件失败&quot;, err);
  }
  console.log(&quot;写入文件成功&quot;);
});
</code></pre>
<p>注意：</p>
<ol>
<li>写文件的时候，会把原来的内容给覆盖掉</li>
</ol>
<h2 id="-">追加文件</h2>
<blockquote>
<p>语法：fs.appendFile(path, data[, options], callback)</p>
</blockquote>
<pre><code class="lang-javascript">//参数1：追加的文件名(如果文件不存在，会自动创建)
//参数2：追加的文件内容（注意：写入的内容会覆盖以前的内容）
//参数3：追加文件后的回调函数
fs.appendFile(&quot;2.txt&quot;, &quot;我是追加的内容&quot;, function(err){
  if(err) {
    return console.log(&quot;追加文件内容失败&quot;);
  }
  console.log(&quot;追加文件内容成功&quot;);
})
</code></pre>
<p>思考：如果没有appendFile，通过readFile与writeFile应该怎么实现？</p>
<h2 id="-">文件同步与异步的说明</h2>
<blockquote>
<p>fs中所有的文件操作，都提供了异步和同步两种方式</p>
</blockquote>
<p>异步方式：不会阻塞代码的执行</p>
<pre><code class="lang-javascript">//异步方式
var fs = require(&quot;fs&quot;);

console.log(111);
fs.readFile(&quot;2.txt&quot;, &quot;utf8&quot;, function(err, data){
  if(err) {
    return console.log(&quot;读取文件失败&quot;, err);
  }
  console.log(data);
});
console.log(&quot;222&quot;);
</code></pre>
<p>同步方式：会阻塞代码的执行</p>
<pre><code class="lang-javascript">//同步方式
console.log(111);
var result = fs.readFileSync(&quot;2.txt&quot;, &quot;utf-8&quot;);
console.log(result);
console.log(222);
</code></pre>
<p>总结：同步操作使用虽然简单，但是会影响性能，因此尽量使用异步方法，尤其是在工作过程中。</p>
<h2 id="-api-">其他api（了解）</h2>
<p>方法有很多，但是用起来都非常的简单，学会查文档</p>
<p>文档：<a href="http://nodejs.cn/api/fs.html">http://nodejs.cn/api/fs.html</a></p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>fs.readFile(path, callback)</code></td>
<td>读取文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.readFileSync(path)</code></td>
<td>读取文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.writeFile(path, data, callback)</code></td>
<td>写入文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.writeFileSync(path, data)</code></td>
<td>写入文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.appendFile(path, data, callback)</code></td>
<td>追加文件内容（异步）</td>
</tr>
<tr>
<td><code>fs.appendFileSync(path, data)</code></td>
<td>追加文件内容（同步）</td>
</tr>
<tr>
<td><code>fs.rename(oldPath, newPath, callback)</code></td>
<td>重命名文件（异步）</td>
</tr>
<tr>
<td><code>fs.renameSync(oldPath, newPath)</code></td>
<td>重命名文件（同步）</td>
</tr>
<tr>
<td><code>fs.unlink(path, callback)</code></td>
<td>删除文件（异步）</td>
</tr>
<tr>
<td><code>fs.unlinkSync(path)</code></td>
<td>删除文件（同步）</td>
</tr>
<tr>
<td><code>fs.mkdir(path, mode, callback)</code></td>
<td>创建文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.mkdirSync(path, mode)</code></td>
<td>创建文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.rmdir(path, callback)</code></td>
<td>删除文件夹（异步）</td>
</tr>
<tr>
<td><code>fs.rmdirSync(path)</code></td>
<td>删除文件夹（同步）</td>
</tr>
<tr>
<td><code>fs.readdir(path, option, callback)</code></td>
<td>读取文件夹内容（异步）</td>
</tr>
<tr>
<td><code>fs.readdirSync(path, option)</code></td>
<td>读取文件夹内容（同步）</td>
</tr>
<tr>
<td><code>fs.stat(path, callback)</code></td>
<td>查看文件状态（异步）</td>
</tr>
<tr>
<td><code>fs.statSync(path)</code></td>
<td>查看文件状态（同步）</td>
</tr>
</tbody>
</table>
<h1 id="path-">path模块</h1>
<h2 id="-">路径操作的问题</h2>
<p>在读写文件的时候，文件路径可以写相对路径或者绝对路径</p>
<pre><code class="lang-javascript">//data.txt是相对路径，读取当前目录下的data.txt, 相对路径相对的是指向node命令的路径
//如果node命令不是在当前目录下执行就会报错， 在当前执行node命令的目录下查找data.txt，找不到
fs.readFile(&quot;data.txt&quot;, &quot;utf8&quot;, function(err, data) {
  if(err) {
    console.log(&quot;读取文件失败&quot;, err);
  }

  console.log(data);
});
</code></pre>
<p>相对路径：相对于执行node命令的路径</p>
<p>绝对路径：<code>__dirname</code>: 当前文件的目录，<code>__filename</code>: 当前文件的目录，包含文件名</p>
<h2 id="path-">path模块的常用方法</h2>
<blockquote>
<p>关于路径，在linux系统中，路径分隔符使用的是<code>/</code>，但是在windows系统中，路径使用的<code>\</code></p>
</blockquote>
<p>在我们拼写路径的时候会带来很多的麻烦，经常会出现windows下写的代码，在linux操作系统下执行不了，path模块就是为了解决这个问题而存在的。</p>
<p>常用方法：</p>
<pre><code class="lang-javascript">path.join();//拼接路径

//windows系统下
&gt; path.join(&quot;abc&quot;,&quot;def&quot;,&quot;gg&quot;, &quot;index.html&quot;)
&quot;abc\def\gg\a.html&quot;

//linux系统下
&gt; path.join(&quot;abc&quot;,&quot;def&quot;,&quot;gg&quot;, &quot;index.html&quot;)
&#39;abc/def/gg/index.html&#39;

path.basename(path[, ext])    返回文件的最后一部分
path.dirname(path)    返回路径的目录名
path.extname(path)    获取路径的扩展名

var path = require(&quot;path&quot;);
var temp = &quot;abc\\def\\gg\\a.html&quot;;
console.log(path.basename(temp));//a.html
console.log(path.dirname(temp));//abc\def\gg
console.log(path.extname(temp));//.html
</code></pre>
<p>【优化读写文件的代码】</p>
<h2 id="path-api-">path模块其他api（了解）</h2>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>path.basename(path[, ext])</code></td>
<td>返回文件的最后一部分</td>
</tr>
<tr>
<td><code>path.dirname(path)</code></td>
<td>返回路径的目录名</td>
</tr>
<tr>
<td><code>path.extname(path)</code></td>
<td>获取路径的扩展名</td>
</tr>
<tr>
<td><code>path.isAbsolute(path)</code></td>
<td>判断目录是否是绝对路径</td>
</tr>
<tr>
<td><code>path.join([...paths])</code></td>
<td>将所有的path片段拼接成一个规范的路径</td>
</tr>
<tr>
<td><code>path.normalize(path)</code></td>
<td>规范化路径</td>
</tr>
<tr>
<td><code>path.parse(path)</code></td>
<td>将一个路径解析成一个path对象</td>
</tr>
<tr>
<td><code>path.format(pathObj)</code></td>
<td>讲一个path对象解析成一个规范的路径</td>
</tr>
</tbody>
</table>
<h1 id="http-">http模块</h1>
<h2 id="-">创建服务器基本步骤</h2>
<pre><code class="lang-javascript">//1. 导入http模块，http模块是node的核心模块，作用是用来创建http服务器的。
var http = require(&quot;http&quot;);

//2. 创建服务器
var server = http.createServer();

//3. 服务器处理请求
server.on(&quot;request&quot;, function() {
  console.log(&quot;我接收到请求了&quot;);
});

//4. 启动服务器，监听某个端口
server.listen(9999, function(){
  console.log(&quot;服务器启动成功了, 请访问： http://localhost:9999&quot;);
});
</code></pre>
<p>详细说明</p>
<ol>
<li>给服务器注册request事件，只要服务器接收到了客户端的请求，就会触发request事件</li>
<li>request事件有两个参数，request表示请求对象，可以获取所有与请求相关的信息，response是响应对象，可以获取所有与响应相关的信息。</li>
<li>服务器监听的端口范围为：1-65535之间，推荐使用3000以上的端口，因为3000以下的端口一般留给系统使用</li>
</ol>
<h2 id="request-">request对象详解</h2>
<p>文档地址：<a href="http://nodejs.cn/api/http.html#http_message_headers">http://nodejs.cn/api/http.html#http_message_headers</a></p>
<p>常见属性：</p>
<pre><code class="lang-javascript">headers: 所有的请求头信息
method： 请求的方式
rawHeaders： 所有的请求头信息（数组的方式）
url： 请求的地址
</code></pre>
<p>注意：在发送请求的时候，可能会出现两次请求的情况，这是因为谷歌浏览器会自动增加一个<code>favicon.ico</code>的请求。</p>
<p>小结：request对象中，常用的就是method和url两个参数</p>
<h2 id="response-">response对象详解</h2>
<p>文档地址：<a href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http://nodejs.cn/api/http.html#http_class_http_serverresponse</a></p>
<p>常见的属性和方法：</p>
<pre><code class="lang-javascript">res.write(data): 给浏览器发送请求体，可以调用多次，从而提供连续的请求体
res.end();   通知服务器，所有响应头和响应主体都已被发送，即服务器将其视为已完成。
res.end(data); 结束请求，并且响应一段内容，相当于res.write(data) + res.end()
res.statusCode: 响应的的状态码 200 404 500
res.statusMessage: 响应的状态信息， OK Not Found ,会根据statusCode自动设置。
res.setHeader(name, value); 设置响应头信息， 比如content-type
res.writeHead(statusCode, statusMessage, options); 设置响应头，同时可以设置状态码和状态信息。
</code></pre>
<p><strong>注意：必须先设置响应头，才能设置响应。</strong> </p>
<h2 id="-">根据不同请求输出不同响应数据</h2>
<ul>
<li><a href="http://nodejs.cn/api/http.html#http_message_url">request.url</a></li>
<li><code>req.url</code>：获取请求路径<ul>
<li>例如：请求<code>http://127.0.0.1:3000/index</code> 获取到的是：<code>/index</code></li>
<li>例如：请求<code>http://127.0.0.1:3000/</code> 获取到的是：<code>/</code></li>
<li>例如：请求<code>http://127.0.0.1:3000</code> 获取到的是：<code>/</code></li>
</ul>
</li>
</ul>
<h2 id="-">服务器响应文件</h2>
<ul>
<li>注意：浏览器中输入的URL地址，仅仅是一个标识，不与服务器中的目录一致。也就是说：返回什么内容是由服务端的逻辑决定</li>
</ul>
<pre><code class="lang-js">server.on(&#39;request&#39;, function(req, res) {
  var url = req.url
  if(url === &#39;/&#39;) {
    fs.readFile(&#39;./index.html&#39;, function(err, data) {
      if(err) {
        return res.end(&#39;您访问的资源不存在~&#39;)
      }

      res.end(data)
    })
  }
})
</code></pre>
<h2 id="-apache-">模拟Apache服务器</h2>
<ul>
<li>根据 <code>req.url</code> 读取不同的页面内容，返回给浏览器</li>
</ul>
<h2 id="mime-">MIME类型</h2>
<ul>
<li>MIME(Multipurpose Internet Mail Extensions)多用途Internet邮件扩展类型 是一种表示文档性质和格式的标准化方式</li>
<li>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；因此服务器将正确的MIME类型附加到响应对象的头部是非常重要的</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_Types">MIME 类型</a></li>
</ul>
<h3 id="mime-">mime模块</h3>
<ul>
<li>作用：获取文件的MIME类型</li>
<li>安装：<code>npm i mime</code></li>
</ul>
<pre><code class="lang-js">var mime = require(&#39;mime&#39;)

// 获取路径对应的MIME类型
mime.getType(&#39;txt&#39;)                    // ⇨ &#39;text/plain&#39;
// 根据MIME获取到文件后缀名
mime.getExtension(&#39;text/plain&#39;)        // ⇨ &#39;txt&#39;
</code></pre>
</article>
  </div>
</body>
</html>
<script type="text/javascript" src="lib/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="lib/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="lib/js/ztree_toc.min.js"></script>
<script type="text/javascript" src="lib/js/toc_conf.js"></script>
<script src="lib/js/highlight.min.js"></script>
<script>
  $(document).ready(function () {
    // 代码高亮的js代码
    hljs.initHighlightingOnLoad();

    //生成侧边栏的代码
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)

    var conf = eval(jquery_ztree_toc_opts);
    $('#tree').ztree_toc(conf);
  });
</script>